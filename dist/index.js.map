{"version":3,"sources":["/Users/duc.le/SideProjects/ts-npm-ytmusic-api/dist/index.js","../src/YTMusic.ts","../src/constants.ts","../src/types.ts","../node_modules/zod-to-json-schema/dist/esm/Options.js","../node_modules/zod-to-json-schema/dist/esm/Refs.js","../node_modules/zod-to-json-schema/dist/esm/errorMessages.js","../node_modules/zod-to-json-schema/dist/esm/getRelativePath.js","../node_modules/zod-to-json-schema/dist/esm/selectParser.js","../node_modules/zod-to-json-schema/dist/esm/parsers/any.js","../node_modules/zod-to-json-schema/dist/esm/parsers/array.js","../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js","../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js","../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js","../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js","../node_modules/zod-to-json-schema/dist/esm/parsers/date.js","../node_modules/zod-to-json-schema/dist/esm/parsers/default.js","../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js","../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js","../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js","../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js","../node_modules/zod-to-json-schema/dist/esm/parsers/record.js","../node_modules/zod-to-json-schema/dist/esm/parsers/string.js","../node_modules/zod-to-json-schema/dist/esm/parsers/map.js","../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js","../node_modules/zod-to-json-schema/dist/esm/parsers/never.js","../node_modules/zod-to-json-schema/dist/esm/parsers/null.js","../node_modules/zod-to-json-schema/dist/esm/parsers/union.js","../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js","../node_modules/zod-to-json-schema/dist/esm/parsers/number.js","../node_modules/zod-to-json-schema/dist/esm/parsers/object.js","../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js","../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js","../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js","../node_modules/zod-to-json-schema/dist/esm/parsers/set.js","../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js","../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js","../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js","../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js","../node_modules/zod-to-json-schema/dist/esm/parseDef.js","../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js","../src/utils/checkType.ts","../src/utils/traverse.ts","../src/utils/filters.ts","../src/parsers/PlaylistParser.ts","../src/parsers/Parser.ts","../src/parsers/SongParser.ts","../src/parsers/AlbumParser.ts","../src/parsers/VideoParser.ts","../src/parsers/ArtistParser.ts","../src/parsers/SearchParser.ts","../src/index.ts"],"names":["ZodFirstPartyTypeKind","types","base","videoId"],"mappings":"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","file":"/Users/duc.le/SideProjects/ts-npm-ytmusic-api/dist/index.js","sourcesContent":[null,"import axios, { AxiosInstance } from \"axios\";\nimport { Cookie, CookieJar } from \"tough-cookie\";\n\nimport { FE_MUSIC_HOME } from \"./constants\";\nimport AlbumParser from \"./parsers/AlbumParser\";\nimport ArtistParser from \"./parsers/ArtistParser\";\nimport Parser from \"./parsers/Parser\";\nimport PlaylistParser from \"./parsers/PlaylistParser\";\nimport SearchParser from \"./parsers/SearchParser\";\nimport SongParser from \"./parsers/SongParser\";\nimport VideoParser from \"./parsers/VideoParser\";\nimport {\n  AlbumDetailed,\n  AlbumFull,\n  ArtistDetailed,\n  ArtistFull,\n  HomeSection,\n  PlaylistDetailed,\n  PlaylistFull,\n  SearchResult,\n  SongDetailed,\n  SongFull,\n  UpNextsDetails,\n  VideoDetailed,\n  VideoFull,\n} from \"./types\";\nimport { traverse, traverseList, traverseString } from \"./utils/traverse\";\n\naxios.defaults.headers.common[\"Accept-Encoding\"] = \"gzip\";\n\nexport default class YTMusic {\n  private cookiejar: CookieJar;\n  private config?: Record<string, string>;\n  private client: AxiosInstance;\n\n  /**\n   * Creates an instance of YTMusic\n   * Make sure to call initialize()\n   */\n  public constructor() {\n    this.cookiejar = new CookieJar();\n    this.config = {};\n    this.client = axios.create({\n      baseURL: \"https://music.youtube.com/\",\n      headers: {\n        \"User-Agent\":\n          \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\",\n        \"Accept-Language\": \"en-US,en;q=0.5\",\n      },\n      withCredentials: true,\n    });\n\n    this.client.interceptors.request.use((req) => {\n      if (req.baseURL) {\n        const cookieString = this.cookiejar.getCookieStringSync(req.baseURL);\n        if (cookieString) {\n          req.headers[\"cookie\"] = cookieString;\n        }\n      }\n\n      return req;\n    });\n\n    this.client.interceptors.response.use((res) => {\n      if (res.headers && res.config.baseURL) {\n        const cookieStrings = res.headers[\"set-cookie\"] || [];\n        for (const cookieString of cookieStrings) {\n          const cookie = Cookie.parse(cookieString);\n          if (cookie) {\n            this.cookiejar.setCookieSync(cookie, res.config.baseURL);\n          }\n        }\n      }\n\n      return res;\n    });\n  }\n\n  /**\n   * Initializes the API\n   */\n  public async initialize(options?: {\n    cookies?: string;\n    GL?: string;\n    HL?: string;\n  }) {\n    const { cookies, GL, HL } = options ?? {};\n\n    if (cookies) {\n      for (const cookieString of cookies.split(\"; \")) {\n        const cookie = Cookie.parse(`${cookieString}`);\n        if (!cookie) return;\n\n        this.cookiejar.setCookieSync(cookie, \"https://www.youtube.com/\");\n      }\n    }\n\n    const html = (await this.client.get(\"/\")).data as string;\n    const setConfigs = html.match(/ytcfg\\.set\\(.*\\)/) || [];\n\n    const configs = setConfigs\n      .map((c) => c.slice(10, -1))\n      .map((s) => {\n        try {\n          return JSON.parse(s);\n        } catch {\n          return null;\n        }\n      })\n      .filter((j) => !!j);\n\n    for (const config of configs) {\n      this.config = {\n        ...this.config,\n        ...config,\n      };\n    }\n\n    if (!this.config) {\n      this.config = {};\n    }\n\n    if (GL) this.config.GL = GL;\n    if (HL) this.config.HL = HL;\n\n    return this;\n  }\n\n  /**\n   * Constructs a basic YouTube Music API request with all essential headers\n   * and body parameters needed to make the API work\n   *\n   * @param endpoint Endpoint for the request\n   * @param body Body\n   * @param query Search params\n   * @returns Raw response from YouTube Music API which needs to be parsed\n   */\n  private async constructRequest(\n    endpoint: string,\n    body: Record<string, any> = {},\n    query: Record<string, string> = {}\n  ) {\n    if (!this.config) {\n      throw new Error(\n        \"API not initialized. Make sure to call the initialize() method first\"\n      );\n    }\n\n    const headers: Record<string, any> = {\n      ...this.client.defaults.headers,\n      \"x-origin\": this.client.defaults.baseURL,\n      \"X-Goog-Visitor-Id\": this.config.VISITOR_DATA || \"\",\n      \"X-YouTube-Client-Name\": this.config.INNERTUBE_CONTEXT_CLIENT_NAME,\n      \"X-YouTube-Client-Version\": this.config.INNERTUBE_CLIENT_VERSION,\n      \"X-YouTube-Device\": this.config.DEVICE,\n      \"X-YouTube-Page-CL\": this.config.PAGE_CL,\n      \"X-YouTube-Page-Label\": this.config.PAGE_BUILD_LABEL,\n      \"X-YouTube-Utc-Offset\": String(-new Date().getTimezoneOffset()),\n      \"X-YouTube-Time-Zone\": new Intl.DateTimeFormat().resolvedOptions()\n        .timeZone,\n    };\n\n    const searchParams = new URLSearchParams({\n      ...query,\n      alt: \"json\",\n      key: this.config.INNERTUBE_API_KEY!,\n    });\n\n    const res = await this.client.post(\n      `youtubei/${\n        this.config.INNERTUBE_API_VERSION\n      }/${endpoint}?${searchParams.toString()}`,\n      {\n        context: {\n          capabilities: {},\n          client: {\n            clientName: this.config.INNERTUBE_CLIENT_NAME,\n            clientVersion: this.config.INNERTUBE_CLIENT_VERSION,\n            experimentIds: [],\n            experimentsToken: \"\",\n            gl: this.config.GL,\n            hl: this.config.HL,\n            locationInfo: {\n              locationPermissionAuthorizationStatus:\n                \"LOCATION_PERMISSION_AUTHORIZATION_STATUS_UNSUPPORTED\",\n            },\n            musicAppInfo: {\n              musicActivityMasterSwitch:\n                \"MUSIC_ACTIVITY_MASTER_SWITCH_INDETERMINATE\",\n              musicLocationMasterSwitch:\n                \"MUSIC_LOCATION_MASTER_SWITCH_INDETERMINATE\",\n              pwaInstallabilityStatus: \"PWA_INSTALLABILITY_STATUS_UNKNOWN\",\n            },\n            utcOffsetMinutes: -new Date().getTimezoneOffset(),\n          },\n          request: {\n            internalExperimentFlags: [\n              {\n                key: \"force_music_enable_outertube_tastebuilder_browse\",\n                value: \"true\",\n              },\n              {\n                key: \"force_music_enable_outertube_playlist_detail_browse\",\n                value: \"true\",\n              },\n              {\n                key: \"force_music_enable_outertube_search_suggestions\",\n                value: \"true\",\n              },\n            ],\n            sessionIndex: {},\n          },\n          user: {\n            enableSafetyMode: false,\n          },\n        },\n        ...body,\n      },\n      {\n        responseType: \"json\",\n        headers,\n      }\n    );\n\n    return \"responseContext\" in res.data ? res.data : res;\n  }\n\n  /**\n   * Get a list of search suggestiong based on the query\n   *\n   * @param query Query string\n   * @returns Search suggestions\n   */\n  public async getSearchSuggestions(query: string): Promise<string[]> {\n    return traverseList(\n      await this.constructRequest(\"music/get_search_suggestions\", {\n        input: query,\n      }),\n      \"query\"\n    );\n  }\n\n  /**\n   * Searches YouTube Music API for results\n   *\n   * @param query Query string\n   */\n  public async search(query: string): Promise<SearchResult[]> {\n    const searchData = await this.constructRequest(\"search\", {\n      query,\n      params: null,\n    });\n\n    return traverseList(searchData, \"musicResponsiveListItemRenderer\")\n      .map(SearchParser.parse)\n      .filter(Boolean) as SearchResult[];\n  }\n\n  /**\n   * Searches YouTube Music API for songs\n   *\n   * @param query Query string\n   */\n  public async searchSongs(query: string): Promise<SongDetailed[]> {\n    const searchData = await this.constructRequest(\"search\", {\n      query,\n      params: \"Eg-KAQwIARAAGAAgACgAMABqChAEEAMQCRAFEAo%3D\",\n    });\n\n    return traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n      SongParser.parseSearchResult\n    );\n  }\n\n  /**\n   * Searches YouTube Music API for videos\n   *\n   * @param query Query string\n   */\n  public async searchVideos(query: string): Promise<VideoDetailed[]> {\n    const searchData = await this.constructRequest(\"search\", {\n      query,\n      params: \"Eg-KAQwIABABGAAgACgAMABqChAEEAMQCRAFEAo%3D\",\n    });\n\n    return traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n      VideoParser.parseSearchResult\n    );\n  }\n\n  /**\n   * Searches YouTube Music API for artists\n   *\n   * @param query Query string\n   */\n  public async searchArtists(query: string): Promise<ArtistDetailed[]> {\n    const searchData = await this.constructRequest(\"search\", {\n      query,\n      params: \"Eg-KAQwIABAAGAAgASgAMABqChAEEAMQCRAFEAo%3D\",\n    });\n\n    return traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n      ArtistParser.parseSearchResult\n    );\n  }\n\n  /**\n   * Searches YouTube Music API for albums\n   *\n   * @param query Query string\n   */\n  public async searchAlbums(query: string): Promise<AlbumDetailed[]> {\n    const searchData = await this.constructRequest(\"search\", {\n      query,\n      params: \"Eg-KAQwIABAAGAEgACgAMABqChAEEAMQCRAFEAo%3D\",\n    });\n\n    return traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n      AlbumParser.parseSearchResult\n    );\n  }\n\n  /**\n   * Searches YouTube Music API for playlists\n   *\n   * @param query Query string\n   */\n  public async searchPlaylists(query: string): Promise<PlaylistDetailed[]> {\n    const searchData = await this.constructRequest(\"search\", {\n      query,\n      params: \"Eg-KAQwIABAAGAAgACgBMABqChAEEAMQCRAFEAo%3D\",\n    });\n\n    return traverseList(searchData, \"musicResponsiveListItemRenderer\").map(\n      PlaylistParser.parseSearchResult\n    );\n  }\n\n  /**\n   * Get all possible information of a Song\n   *\n   * @param videoId Video ID\n   * @returns Song Data\n   */\n  public async getSong(videoId: string): Promise<SongFull> {\n    if (!videoId.match(/^[a-zA-Z0-9-_]{11}$/))\n      throw new Error(\"Invalid videoId\");\n    const data = await this.constructRequest(\"player\", { videoId });\n\n    const song = SongParser.parse(data);\n    if (song.videoId !== videoId) throw new Error(\"Invalid videoId\");\n    return song;\n  }\n\n  /**\n   * Get all possible information of a Up Nexts Song\n   *\n   * @param videoId Video ID\n   * @returns Up Nexts Data\n   */\n\n  async getUpNexts(videoId: string): Promise<UpNextsDetails[]> {\n    if (!videoId.match(/^[a-zA-Z0-9-_]{11}$/))\n      throw new Error(\"Invalid videoId\");\n\n    const data = await this.constructRequest(\"next\", {\n      videoId,\n      playlistId: `RDAMVM${videoId}`,\n      isAudioOnly: true,\n    });\n\n    const tabs =\n      data?.contents?.singleColumnMusicWatchNextResultsRenderer?.tabbedRenderer\n        ?.watchNextTabbedResultsRenderer?.tabs[0]?.tabRenderer?.content\n        ?.musicQueueRenderer?.content?.playlistPanelRenderer?.contents;\n\n    if (!tabs) throw new Error(\"Invalid response structure\");\n\n    return tabs.slice(1).map((item: any) => {\n      const { videoId, title, shortBylineText, lengthText, thumbnail } =\n        item.playlistPanelVideoRenderer;\n      return {\n        type: \"SONG\",\n        videoId,\n        title: title?.runs[0]?.text || \"Unknown\",\n        artists: shortBylineText?.runs[0]?.text || \"Unknown\",\n        duration: lengthText?.runs[0]?.text || \"Unknown\",\n        thumbnail: thumbnail?.thumbnails.at(-1)?.url || \"Unknown\",\n      };\n    });\n  }\n\n  /**\n   * Get all possible information of a Video\n   *\n   * @param videoId Video ID\n   * @returns Video Data\n   */\n  public async getVideo(videoId: string): Promise<VideoFull> {\n    if (!videoId.match(/^[a-zA-Z0-9-_]{11}$/))\n      throw new Error(\"Invalid videoId\");\n    const data = await this.constructRequest(\"player\", { videoId });\n\n    const video = VideoParser.parse(data);\n    if (video.videoId !== videoId) throw new Error(\"Invalid videoId\");\n    return video;\n  }\n\n  /**\n   * Get lyrics of a specific Song\n   *\n   * @param videoId Video ID\n   * @returns Lyrics\n   */\n  public async getLyrics(videoId: string) {\n    if (!videoId.match(/^[a-zA-Z0-9-_]{11}$/))\n      throw new Error(\"Invalid videoId\");\n    const data = await this.constructRequest(\"next\", { videoId });\n    const browseId = traverse(\n      traverseList(data, \"tabs\", \"tabRenderer\")[1],\n      \"browseId\"\n    );\n\n    const lyricsData = await this.constructRequest(\"browse\", { browseId });\n    const lyrics = traverseString(lyricsData, \"description\", \"runs\", \"text\");\n\n    return lyrics\n      ? lyrics\n          .replaceAll(\"\\r\", \"\")\n          .split(\"\\n\")\n          .filter((v) => !!v)\n      : null;\n  }\n\n  /**\n   * Get timed lyrics of a specific Song\n   *\n   * @param videoId Video ID\n   * @returns Lyrics\n   */\n  public async getTimedLyrics(videoId: string) {\n    if (!videoId.match(/^[a-zA-Z0-9-_]{11}$/))\n      throw new Error(\"Invalid videoId\");\n    const data = await this.constructRequest(\"next\", { videoId });\n    const browseId = traverse(\n      traverseList(data, \"tabs\", \"tabRenderer\")[1],\n      \"browseId\"\n    );\n\n    const lyricsData = await this.constructRequest(\"browse\", { browseId });\n    const timedLyrics = traverseString(\n      lyricsData,\n      \"contents\",\n      \"type\",\n      \"lyricsData\"\n    );\n    return timedLyrics;\n  }\n\n  /**\n   * Get all possible information of an Artist\n   *\n   * @param artistId Artist ID\n   * @returns Artist Data\n   */\n  public async getArtist(artistId: string): Promise<ArtistFull> {\n    const data = await this.constructRequest(\"browse\", {\n      browseId: artistId,\n    });\n\n    return ArtistParser.parse(data, artistId);\n  }\n\n  /**\n   * Get all of Artist's Songs\n   *\n   * @param artistId Artist ID\n   * @returns Artist's Songs\n   */\n  public async getArtistSongs(artistId: string): Promise<SongDetailed[]> {\n    const artistData = await this.constructRequest(\"browse\", {\n      browseId: artistId,\n    });\n    const browseToken = traverse(\n      artistData,\n      \"musicShelfRenderer\",\n      \"title\",\n      \"browseId\"\n    );\n\n    if (browseToken instanceof Array) return [];\n\n    const songsData = await this.constructRequest(\"browse\", {\n      browseId: browseToken,\n    });\n    const continueToken = traverse(songsData, \"continuation\");\n    const moreSongsData = await this.constructRequest(\n      \"browse\",\n      {},\n      { continuation: continueToken }\n    );\n\n    return [\n      ...traverseList(songsData, \"musicResponsiveListItemRenderer\"),\n      ...traverseList(moreSongsData, \"musicResponsiveListItemRenderer\"),\n    ].map((s) =>\n      SongParser.parseArtistSong(s, {\n        artistId,\n        name: traverseString(artistData, \"header\", \"title\", \"text\"),\n      })\n    );\n  }\n\n  /**\n   * Get all of Artist's Albums\n   *\n   * @param artistId Artist ID\n   * @returns Artist's Albums\n   */\n  public async getArtistAlbums(artistId: string): Promise<AlbumDetailed[]> {\n    const artistData = await this.constructRequest(\"browse\", {\n      browseId: artistId,\n    });\n    const artistAlbumsData = traverseList(\n      artistData,\n      \"musicCarouselShelfRenderer\"\n    )[0];\n    const browseBody = traverse(\n      artistAlbumsData,\n      \"moreContentButton\",\n      \"browseEndpoint\"\n    );\n\n    const albumsData = await this.constructRequest(\"browse\", browseBody);\n\n    return traverseList(albumsData, \"musicTwoRowItemRenderer\").map((item) =>\n      AlbumParser.parseArtistAlbum(item, {\n        artistId,\n        name: traverseString(albumsData, \"header\", \"runs\", \"text\"),\n      })\n    );\n  }\n\n  /**\n   * Get all possible information of an Album\n   *\n   * @param albumId Album ID\n   * @returns Album Data\n   */\n  public async getAlbum(albumId: string): Promise<AlbumFull> {\n    const data = await this.constructRequest(\"browse\", {\n      browseId: albumId,\n    });\n\n    return AlbumParser.parse(data, albumId);\n  }\n\n  /**\n   * Get all possible information of a Playlist except the tracks\n   *\n   * @param playlistId Playlist ID\n   * @returns Playlist Data\n   */\n  public async getPlaylist(playlistId: string): Promise<PlaylistFull> {\n    if (playlistId.startsWith(\"PL\")) playlistId = \"VL\" + playlistId;\n    const data = await this.constructRequest(\"browse\", {\n      browseId: playlistId,\n    });\n\n    return PlaylistParser.parse(data, playlistId);\n  }\n\n  /**\n   * Get all videos in a Playlist\n   *\n   * @param playlistId Playlist ID\n   * @returns Playlist's Videos\n   */\n  public async getPlaylistVideos(playlistId: string): Promise<VideoDetailed[]> {\n    if (playlistId.startsWith(\"PL\")) playlistId = \"VL\" + playlistId;\n    const playlistData = await this.constructRequest(\"browse\", {\n      browseId: playlistId,\n    });\n\n    const songs = traverseList(\n      playlistData,\n      \"musicPlaylistShelfRenderer\",\n      \"musicResponsiveListItemRenderer\"\n    );\n    let continuation = traverse(playlistData, \"continuation\");\n    // Sometimes it returns array, dunno why\n    if (continuation instanceof Array) {\n      continuation = continuation[0];\n    }\n\n    while (!(continuation instanceof Array)) {\n      const songsData = await this.constructRequest(\n        \"browse\",\n        {},\n        { continuation }\n      );\n      songs.push(...traverseList(songsData, \"musicResponsiveListItemRenderer\"));\n      continuation = traverse(songsData, \"continuation\");\n    }\n\n    return songs\n      .map(VideoParser.parsePlaylistVideo)\n      .filter((video): video is VideoDetailed => video !== undefined);\n  }\n\n  /**\n   * Get sections for the home page.\n   *\n   * @returns Mixed HomeSection\n   */\n  public async getHomeSections(): Promise<HomeSection[]> {\n    const data = await this.constructRequest(\"browse\", {\n      browseId: FE_MUSIC_HOME,\n    });\n\n    const sections = traverseList(\"sectionListRenderer\", \"contents\");\n    let continuation = traverseString(data, \"continuation\");\n    while (continuation) {\n      const data = await this.constructRequest(\"browse\", {}, { continuation });\n      sections.push(\n        ...traverseList(data, \"sectionListContinuation\", \"contents\")\n      );\n      continuation = traverseString(data, \"continuation\");\n    }\n\n    return sections.map(Parser.parseHomeSection);\n  }\n}\n","export enum PageType {\n\tMUSIC_PAGE_TYPE_ALBUM = \"MUSIC_PAGE_TYPE_ALBUM\",\n\tMUSIC_PAGE_TYPE_PLAYLIST = \"MUSIC_PAGE_TYPE_PLAYLIST\",\n\tMUSIC_VIDEO_TYPE_OMV = \"MUSIC_VIDEO_TYPE_OMV\",\n}\n\nexport const FE_MUSIC_HOME = \"FEmusic_home\"\n","import { z } from \"zod\"\n\nexport type ThumbnailFull = z.infer<typeof ThumbnailFull>\nexport const ThumbnailFull = z\n\t.object({\n\t\turl: z.string(),\n\t\twidth: z.number(),\n\t\theight: z.number(),\n\t})\n\t.strict()\n\nexport type ArtistBasic = z.infer<typeof ArtistBasic>\nexport const ArtistBasic = z\n\t.object({\n\t\tartistId: z.nullable(z.string()),\n\t\tname: z.string(),\n\t})\n\t.strict()\n\nexport type AlbumBasic = z.infer<typeof AlbumBasic>\nexport const AlbumBasic = z\n\t.object({\n\t\talbumId: z.string(),\n\t\tname: z.string(),\n\t})\n\t.strict()\n\nexport type SongDetailed = z.infer<typeof SongDetailed>\nexport const SongDetailed = z\n\t.object({\n\t\ttype: z.literal(\"SONG\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\talbum: z.nullable(AlbumBasic),\n\t\tduration: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type VideoDetailed = z.infer<typeof VideoDetailed>\nexport const VideoDetailed = z\n\t.object({\n\t\ttype: z.literal(\"VIDEO\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tduration: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type ArtistDetailed = z.infer<typeof ArtistDetailed>\nexport const ArtistDetailed = z\n\t.object({\n\t\tartistId: z.string(),\n\t\tname: z.string(),\n\t\ttype: z.literal(\"ARTIST\"),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type AlbumDetailed = z.infer<typeof AlbumDetailed>\nexport const AlbumDetailed = z\n\t.object({\n\t\ttype: z.literal(\"ALBUM\"),\n\t\talbumId: z.string(),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tyear: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type PlaylistDetailed = z.infer<typeof PlaylistDetailed>\nexport const PlaylistDetailed = z\n\t.object({\n\t\ttype: z.literal(\"PLAYLIST\"),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type SongFull = z.infer<typeof SongFull>\nexport const SongFull = z\n\t.object({\n\t\ttype: z.literal(\"SONG\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tduration: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\tformats: z.array(z.any()),\n\t\tadaptiveFormats: z.array(z.any()),\n\t})\n\t.strict()\n\nexport type VideoFull = z.infer<typeof VideoFull>\nexport const VideoFull = z\n\t.object({\n\t\ttype: z.literal(\"VIDEO\"),\n\t\tvideoId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tduration: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\tunlisted: z.boolean(),\n\t\tfamilySafe: z.boolean(),\n\t\tpaid: z.boolean(),\n\t\ttags: z.array(z.string()),\n\t})\n\t.strict()\n\nexport type UpNextsDetails = z.infer<typeof UpNextsDetails>\nexport const UpNextsDetails = z\n\t\t.object({\n\t\ttype: z.literal(\"SONG\"),\n\t\tvideoId: z.string(),\n\t\ttitle: z.string(),\n\t\tartists: ArtistBasic,\n\t\tduration: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\t})\n\t\t.strict()\n\t\t\nexport type ArtistFull = z.infer<typeof ArtistFull>\nexport const ArtistFull = z\n\t.object({\n\t\tartistId: z.string(),\n\t\tname: z.string(),\n\t\ttype: z.literal(\"ARTIST\"),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\ttopSongs: z.array(SongDetailed),\n\t\ttopAlbums: z.array(AlbumDetailed),\n\t\ttopSingles: z.array(AlbumDetailed),\n\t\ttopVideos: z.array(VideoDetailed),\n\t\tfeaturedOn: z.array(PlaylistDetailed),\n\t\tsimilarArtists: z.array(ArtistDetailed),\n\t})\n\t.strict()\n\nexport type AlbumFull = z.infer<typeof AlbumFull>\nexport const AlbumFull = z\n\t.object({\n\t\ttype: z.literal(\"ALBUM\"),\n\t\talbumId: z.string(),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tyear: z.nullable(z.number()),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t\tsongs: z.array(SongDetailed),\n\t})\n\t.strict()\n\nexport type PlaylistFull = z.infer<typeof PlaylistFull>\nexport const PlaylistFull = z\n\t.object({\n\t\ttype: z.literal(\"PLAYLIST\"),\n\t\tplaylistId: z.string(),\n\t\tname: z.string(),\n\t\tartist: ArtistBasic,\n\t\tvideoCount: z.number(),\n\t\tthumbnails: z.array(ThumbnailFull),\n\t})\n\t.strict()\n\nexport type SearchResult = z.infer<typeof SearchResult>\nexport const SearchResult = z.discriminatedUnion(\"type\", [\n\tSongDetailed,\n\tVideoDetailed,\n\tAlbumDetailed,\n\tArtistDetailed,\n\tPlaylistDetailed,\n])\n\nexport type HomeSection = z.infer<typeof HomeSection>\nexport const HomeSection = z\n\t.object({\n\t\ttitle: z.string(),\n\t\tcontents: z.array(z.union([AlbumDetailed, PlaylistDetailed, SongDetailed])),\n\t})\n\t.strict()\n","export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n    openAiAnyTypeName: \"OpenAiAnyType\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n","import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        flags: { hasReferencedOpenAiAnyType: false },\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n","export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n","export const getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef(refs);\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef(refs);\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef(refs);\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef(refs);\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            /* c8 ignore next */\n            return ((_) => undefined)(typeName);\n    }\n};\n","import { getRelativePath } from \"../getRelativePath.js\";\nexport function parseAnyDef(refs) {\n    if (refs.target !== \"openAi\") {\n        return {};\n    }\n    const anyDefinitionPath = [\n        ...refs.basePath,\n        refs.definitionPath,\n        refs.openAiAnyTypeName,\n    ];\n    refs.flags.hasReferencedOpenAiAnyType = true;\n    return {\n        $ref: refs.$refStrategy === \"relative\"\n            ? getRelativePath(anyDefinitionPath, refs.currentPath)\n            : anyDefinitionPath.join(\"/\"),\n    };\n}\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : parseAnyDef(refs);\n}\n","export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n","export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n","import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? parseAnyDef(refs),\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || parseAnyDef(refs);\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || parseAnyDef(refs);\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n","export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseNeverDef(refs) {\n    return refs.target === \"openAi\"\n        ? undefined\n        : {\n            not: parseAnyDef({\n                ...refs,\n                currentPath: [...refs.currentPath, \"not\"],\n            }),\n        };\n}\n","export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n","import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef._def.typeName === \"ZodOptional\") {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: parseAnyDef(refs),\n                },\n                innerSchema,\n            ],\n        }\n        : parseAnyDef(refs);\n};\n","import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n","import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUndefinedDef(refs) {\n    return {\n        not: parseAnyDef(refs),\n    };\n}\n","import { parseAnyDef } from \"./any.js\";\nexport function parseUnknownDef(refs) {\n    return parseAnyDef(refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n","import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    let definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? parseAnyDef(refs),\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? parseAnyDef(refs);\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    if (refs.flags.hasReferencedOpenAiAnyType) {\n        if (!definitions) {\n            definitions = {};\n        }\n        if (!definitions[refs.openAiAnyTypeName]) {\n            definitions[refs.openAiAnyTypeName] = {\n                // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n                type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n                items: {\n                    $ref: refs.$refStrategy === \"relative\"\n                        ? \"1\"\n                        : [\n                            ...refs.basePath,\n                            refs.definitionPath,\n                            refs.openAiAnyTypeName,\n                        ].join(\"/\"),\n                },\n            };\n        }\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n","import { ZodType } from \"zod\"\nimport { zodToJsonSchema } from \"zod-to-json-schema\"\n\nexport default <T>(data: T, type: ZodType<T>): T => {\n\tconst result = type.safeParse(data)\n\n\tif (result.error) {\n\t\tconsole.error(\n\t\t\t\"Invalid data type, please report to https://github.com/zS1L3NT/ts-npm-ytmusic-api/issues/new/choose\",\n\t\t\tJSON.stringify(\n\t\t\t\t{\n\t\t\t\t\tdata,\n\t\t\t\t\tschema: zodToJsonSchema(type, \"schema\"),\n\t\t\t\t\terror: result.error,\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2,\n\t\t\t),\n\t\t)\n\t}\n\n\treturn data\n}\n","export const traverse = (data: any, ...keys: string[]) => {\n\tconst again = (data: any, key: string, deadEnd = false): any => {\n\t\tconst res = []\n\n\t\tif (data instanceof Object && key in data) {\n\t\t\tres.push(data[key])\n\t\t\tif (deadEnd) return res.length === 1 ? res[0] : res\n\t\t}\n\n\t\tif (data instanceof Array) {\n\t\t\tres.push(...data.map(v => again(v, key)).flat())\n\t\t} else if (data instanceof Object) {\n\t\t\tres.push(\n\t\t\t\t...Object.keys(data)\n\t\t\t\t\t.map(k => again(data[k], key))\n\t\t\t\t\t.flat(),\n\t\t\t)\n\t\t}\n\n\t\treturn res.length === 1 ? res[0] : res\n\t}\n\n\tlet value = data\n\tconst lastKey = keys.at(-1)\n\tfor (const key of keys) {\n\t\tvalue = again(value, key, lastKey === key)\n\t}\n\n\treturn value\n}\n\nexport const traverseList = (data: any, ...keys: string[]): any[] => {\n\treturn [traverse(data, ...keys)].flat()\n}\n\nexport const traverseString = (data: any, ...keys: string[]): string => {\n\treturn traverseList(data, ...keys).at(0) || \"\"\n}\n","import { traverseString } from \"./traverse\"\n\nexport const isTitle = (data: any) => {\n\treturn traverseString(data, \"musicVideoType\").startsWith(\"MUSIC_VIDEO_TYPE_\")\n}\n\nexport const isArtist = (data: any) => {\n\treturn [\"MUSIC_PAGE_TYPE_USER_CHANNEL\", \"MUSIC_PAGE_TYPE_ARTIST\"].includes(\n\t\ttraverseString(data, \"pageType\"),\n\t)\n}\n\nexport const isAlbum = (data: any) => {\n\treturn traverseString(data, \"pageType\") === \"MUSIC_PAGE_TYPE_ALBUM\"\n}\n\nexport const isDuration = (data: any) => {\n\treturn traverseString(data, \"text\").match(/(\\d{1,2}:)?\\d{1,2}:\\d{1,2}/)\n}\n","import { ArtistBasic, PlaylistDetailed, PlaylistFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isArtist } from \"../utils/filters\"\nimport { traverse, traverseList, traverseString } from \"../utils/traverse\"\n\nexport default class PlaylistParser {\n\tpublic static parse(data: any, playlistId: string): PlaylistFull {\n\t\tconst artist = traverse(data, \"tabs\", \"straplineTextOne\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId,\n\t\t\t\tname: traverseString(data, \"tabs\", \"title\", \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tvideoCount:\n\t\t\t\t\t+traverseList(data, \"tabs\", \"secondSubtitle\", \"text\")\n\t\t\t\t\t\t.at(2)\n\t\t\t\t\t\t.split(\" \")\n\t\t\t\t\t\t.at(0)\n\t\t\t\t\t\t.replaceAll(\",\", \"\") ?? null,\n\t\t\t\tthumbnails: traverseList(data, \"tabs\", \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): PlaylistDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\t// No specific way to identify the title\n\t\tconst title = columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[3]\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId: traverseString(item, \"overlay\", \"playlistId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistFeaturedOn(item: any, artistBasic: ArtistBasic): PlaylistDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId: traverseString(item, \"navigationEndpoint\", \"browseId\"),\n\t\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistDetailed,\n\t\t)\n\t}\n\n\tpublic static parseHomeSection(item: any): PlaylistDetailed {\n\t\tconst artist = traverse(item, \"subtitle\", \"runs\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"PLAYLIST\",\n\t\t\t\tplaylistId: traverseString(item, \"navigationEndpoint\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tPlaylistDetailed,\n\t\t)\n\t}\n}\n","import { PageType } from \"../constants\"\nimport { AlbumDetailed, HomeSection } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { traverseList, traverseString } from \"../utils/traverse\"\nimport AlbumParser from \"./AlbumParser\"\nimport PlaylistParser from \"./PlaylistParser\"\nimport SongParser from \"./SongParser\"\n\nexport default class Parser {\n\tpublic static parseDuration(time: string) {\n\t\tif (!time) return null\n\n\t\tconst [seconds, minutes, hours] = time\n\t\t\t.split(\":\")\n\t\t\t.reverse()\n\t\t\t.map(n => +n) as (number | undefined)[]\n\n\t\treturn (seconds || 0) + (minutes || 0) * 60 + (hours || 0) * 60 * 60\n\t}\n\n\tpublic static parseNumber(string: string): number {\n\t\tif (string.at(-1)!.match(/^[A-Z]+$/)) {\n\t\t\tconst number = +string.slice(0, -1)\n\t\t\tconst multiplier = string.at(-1)\n\n\t\t\treturn (\n\t\t\t\t{\n\t\t\t\t\tK: number * 1000,\n\t\t\t\t\tM: number * 1000 * 1000,\n\t\t\t\t\tB: number * 1000 * 1000 * 1000,\n\t\t\t\t\tT: number * 1000 * 1000 * 1000 * 1000,\n\t\t\t\t}[multiplier!] || NaN\n\t\t\t)\n\t\t} else {\n\t\t\treturn +string\n\t\t}\n\t}\n\n\tpublic static parseHomeSection(data: any): HomeSection {\n\t\tconst pageType = traverseString(data, \"contents\", \"title\", \"browseEndpoint\", \"pageType\")\n\t\tconst playlistId = traverseString(\n\t\t\tdata,\n\t\t\t\"navigationEndpoint\",\n\t\t\t\"watchPlaylistEndpoint\",\n\t\t\t\"playlistId\",\n\t\t)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttitle: traverseString(data, \"header\", \"title\", \"text\"),\n\t\t\t\tcontents: traverseList(data, \"contents\").map(item => {\n\t\t\t\t\tswitch (pageType) {\n\t\t\t\t\t\tcase PageType.MUSIC_PAGE_TYPE_ALBUM:\n\t\t\t\t\t\t\treturn AlbumParser.parseHomeSection(item)\n\t\t\t\t\t\tcase PageType.MUSIC_PAGE_TYPE_PLAYLIST:\n\t\t\t\t\t\t\treturn PlaylistParser.parseHomeSection(item)\n\t\t\t\t\t\tcase \"\":\n\t\t\t\t\t\t\tif (playlistId) {\n\t\t\t\t\t\t\t\treturn PlaylistParser.parseHomeSection(item)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn SongParser.parseHomeSection(item)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null as unknown as AlbumDetailed\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t},\n\t\t\tHomeSection,\n\t\t)\n\t}\n}\n","import { AlbumBasic, ArtistBasic, SongDetailed, SongFull, ThumbnailFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isAlbum, isArtist, isDuration, isTitle } from \"../utils/filters\"\nimport { traverseList, traverseString } from \"../utils/traverse\"\nimport Parser from \"./Parser\"\n\nexport default class SongParser {\n\tpublic static parse(data: any): SongFull {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(data, \"videoDetails\", \"videoId\"),\n\t\t\t\tname: traverseString(data, \"videoDetails\", \"title\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(data, \"author\"),\n\t\t\t\t\tartistId: traverseString(data, \"videoDetails\", \"channelId\"),\n\t\t\t\t},\n\t\t\t\tduration: +traverseString(data, \"videoDetails\", \"lengthSeconds\"),\n\t\t\t\tthumbnails: traverseList(data, \"videoDetails\", \"thumbnails\"),\n\t\t\t\tformats: traverseList(data, \"streamingData\", \"formats\"),\n\t\t\t\tadaptiveFormats: traverseList(data, \"streamingData\", \"adaptiveFormats\"),\n\t\t\t},\n\t\t\tSongFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): SongDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\")\n\n\t\t// It is not possible to identify the title and author\n\t\tconst title = columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[3]\n\t\tconst album = columns.find(isAlbum) ?? null\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\talbum: album\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tname: traverseString(album, \"text\"),\n\t\t\t\t\t\t\talbumId: traverseString(album, \"browseId\"),\n\t\t\t\t\t\t}\n\t\t\t\t\t: null,\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistSong(item: any, artistBasic: ArtistBasic): SongDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle)\n\t\tconst album = columns.find(isAlbum)\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\talbum: album\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tname: traverseString(album, \"text\"),\n\t\t\t\t\t\t\talbumId: traverseString(album, \"browseId\"),\n\t\t\t\t\t\t}\n\t\t\t\t\t: null,\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistTopSong(item: any, artistBasic: ArtistBasic): SongDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle)\n\t\tconst album = columns.find(isAlbum)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\talbum: {\n\t\t\t\t\tname: traverseString(album, \"text\"),\n\t\t\t\t\talbumId: traverseString(album, \"browseId\"),\n\t\t\t\t},\n\t\t\t\tduration: null,\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseAlbumSong(\n\t\titem: any,\n\t\tartistBasic: ArtistBasic,\n\t\talbumBasic: AlbumBasic,\n\t\tthumbnails: ThumbnailFull[],\n\t): SongDetailed {\n\t\tconst title = traverseList(item, \"flexColumns\", \"runs\").find(isTitle)\n\t\tconst duration = traverseList(item, \"fixedColumns\", \"runs\").find(isDuration)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"SONG\",\n\t\t\t\tvideoId: traverseString(item, \"playlistItemData\", \"videoId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\talbum: albumBasic,\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails,\n\t\t\t},\n\t\t\tSongDetailed,\n\t\t)\n\t}\n\n\tpublic static parseHomeSection(item: any) {\n\t\treturn SongParser.parseSearchResult(item)\n\t}\n}\n","import { AlbumBasic, AlbumDetailed, AlbumFull, ArtistBasic } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isArtist } from \"../utils/filters\"\nimport { traverse, traverseList, traverseString } from \"../utils/traverse\"\nimport SongParser from \"./SongParser\"\n\nexport default class AlbumParser {\n\tpublic static parse(data: any, albumId: string): AlbumFull {\n\t\tconst albumBasic: AlbumBasic = {\n\t\t\talbumId,\n\t\t\tname: traverseString(data, \"tabs\", \"title\", \"text\"),\n\t\t}\n\n\t\tconst artistData = traverse(data, \"tabs\", \"straplineTextOne\", \"runs\")\n\t\tconst artistBasic: ArtistBasic = {\n\t\t\tartistId: traverseString(artistData, \"browseId\") || null,\n\t\t\tname: traverseString(artistData, \"text\"),\n\t\t}\n\n\t\tconst thumbnails = traverseList(data, \"background\", \"thumbnails\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\t...albumBasic,\n\t\t\t\tplaylistId: traverseString(data, \"musicPlayButtonRenderer\", \"playlistId\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tyear: AlbumParser.processYear(\n\t\t\t\t\ttraverseList(data, \"tabs\", \"subtitle\", \"text\").at(-1),\n\t\t\t\t),\n\t\t\t\tthumbnails,\n\t\t\t\tsongs: traverseList(data, \"musicResponsiveListItemRenderer\").map(item =>\n\t\t\t\t\tSongParser.parseAlbumSong(item, artistBasic, albumBasic, thumbnails),\n\t\t\t\t),\n\t\t\t},\n\t\t\tAlbumFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): AlbumDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\t// No specific way to identify the title\n\t\tconst title = columns[0]\n\t\tconst artist = columns.find(isArtist) || columns[3]\n\t\tconst playlistId =\n\t\t\ttraverseString(item, \"overlay\", \"playlistId\") ||\n\t\t\ttraverseString(item, \"thumbnailOverlay\", \"playlistId\")\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseList(item, \"browseId\").at(-1),\n\t\t\t\tplaylistId,\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tyear: AlbumParser.processYear(columns.at(-1)?.text),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistAlbum(item: any, artistBasic: ArtistBasic): AlbumDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseList(item, \"browseId\").at(-1),\n\t\t\t\tplaylistId: traverseString(item, \"thumbnailOverlay\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"title\", \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tyear: AlbumParser.processYear(traverseList(item, \"subtitle\", \"text\").at(-1)),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tpublic static parseArtistTopAlbum(item: any, artistBasic: ArtistBasic): AlbumDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseList(item, \"browseId\").at(-1),\n\t\t\t\tplaylistId: traverseString(item, \"musicPlayButtonRenderer\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"title\", \"text\"),\n\t\t\t\tartist: artistBasic,\n\t\t\t\tyear: AlbumParser.processYear(traverseList(item, \"subtitle\", \"text\").at(-1)),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tpublic static parseHomeSection(item: any): AlbumDetailed {\n\t\tconst artist = traverse(item, \"subtitle\", \"runs\").at(-1)\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ALBUM\",\n\t\t\t\talbumId: traverseString(item, \"title\", \"browseId\"),\n\t\t\t\tplaylistId: traverseString(item, \"thumbnailOverlay\", \"playlistId\"),\n\t\t\t\tname: traverseString(item, \"title\", \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tyear: null,\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tAlbumDetailed,\n\t\t)\n\t}\n\n\tprivate static processYear(year: string) {\n\t\treturn year && year.match(/^\\d{4}$/) ? +year : null\n\t}\n}\n","import { ArtistBasic, VideoDetailed, VideoFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { isArtist, isDuration, isTitle } from \"../utils/filters\"\nimport { traverse, traverseList, traverseString } from \"../utils/traverse\"\nimport Parser from \"./Parser\"\n\nexport default class VideoParser {\n\tpublic static parse(data: any): VideoFull {\n\t\treturn {\n\t\t\ttype: \"VIDEO\",\n\t\t\tvideoId: traverseString(data, \"videoDetails\", \"videoId\"),\n\t\t\tname: traverseString(data, \"videoDetails\", \"title\"),\n\t\t\tartist: {\n\t\t\t\tartistId: traverseString(data, \"videoDetails\", \"channelId\"),\n\t\t\t\tname: traverseString(data, \"author\"),\n\t\t\t},\n\t\t\tduration: +traverseString(data, \"videoDetails\", \"lengthSeconds\"),\n\t\t\tthumbnails: traverseList(data, \"videoDetails\", \"thumbnails\"),\n\t\t\tunlisted: traverse(data, \"unlisted\"),\n\t\t\tfamilySafe: traverse(data, \"familySafe\"),\n\t\t\tpaid: traverse(data, \"paid\"),\n\t\t\ttags: traverseList(data, \"tags\"),\n\t\t}\n\t}\n\n\tpublic static parseSearchResult(item: any): VideoDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\tconst title = columns.find(isTitle)\n\t\tconst artist = columns.find(isArtist) || columns[1]\n\t\tconst duration = columns.find(isDuration)\n\n\t\treturn {\n\t\t\ttype: \"VIDEO\",\n\t\t\tvideoId: traverseString(item, \"playNavigationEndpoint\", \"videoId\"),\n\t\t\tname: traverseString(title, \"text\"),\n\t\t\tartist: {\n\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t},\n\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t}\n\t}\n\n\tpublic static parseArtistTopVideo(item: any, artistBasic: ArtistBasic): VideoDetailed {\n\t\treturn {\n\t\t\ttype: \"VIDEO\",\n\t\t\tvideoId: traverseString(item, \"videoId\"),\n\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\tartist: artistBasic,\n\t\t\tduration: null,\n\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t}\n\t}\n\n\tpublic static parsePlaylistVideo(item: any): VideoDetailed | undefined {\n\t\tconst flexColumns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\t\tconst fixedcolumns = traverseList(item, \"fixedColumns\", \"runs\").flat()\n\n\t\tconst title = flexColumns.find(isTitle) || flexColumns[0]\n\t\tconst artist = flexColumns.find(isArtist) || flexColumns[1]\n\t\tconst duration = fixedcolumns.find(isDuration)\n\n\t\tconst videoId1: string = traverseString(item, \"playNavigationEndpoint\", \"videoId\")\n\t\tconst videoId2: string[] = traverseList(item, \"thumbnails\")[0].url.match(/https:\\/\\/i\\.ytimg\\.com\\/vi\\/(.+)\\//,)\n\n\t\tif (videoId1 == '' && videoId2 == null) {\n\t\t\treturn\n\t\t}\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"VIDEO\",\n\t\t\t\tvideoId: videoId1 || videoId2[1] as string,\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tartist: {\n\t\t\t\t\tname: traverseString(artist, \"text\"),\n\t\t\t\t\tartistId: traverseString(artist, \"browseId\") || null,\n\t\t\t\t},\n\t\t\t\tduration: Parser.parseDuration(duration?.text),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tVideoDetailed,\n\t\t)\n\t}\n}\n","import { ArtistDetailed, ArtistFull } from \"../types\"\nimport checkType from \"../utils/checkType\"\nimport { traverseList, traverseString } from \"../utils/traverse\"\nimport AlbumParser from \"./AlbumParser\"\nimport PlaylistParser from \"./PlaylistParser\"\nimport SongParser from \"./SongParser\"\nimport VideoParser from \"./VideoParser\"\n\nexport default class ArtistParser {\n\tpublic static parse(data: any, artistId: string): ArtistFull {\n\t\tconst artistBasic = {\n\t\t\tartistId,\n\t\t\tname: traverseString(data, \"header\", \"title\", \"text\"),\n\t\t}\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ARTIST\",\n\t\t\t\t...artistBasic,\n\t\t\t\tthumbnails: traverseList(data, \"header\", \"thumbnails\"),\n\t\t\t\ttopSongs: traverseList(data, \"musicShelfRenderer\", \"contents\").map(item =>\n\t\t\t\t\tSongParser.parseArtistTopSong(item, artistBasic),\n\t\t\t\t),\n\t\t\t\ttopAlbums:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(0)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tAlbumParser.parseArtistTopAlbum(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\ttopSingles:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(1)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tAlbumParser.parseArtistTopAlbum(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\ttopVideos:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(2)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tVideoParser.parseArtistTopVideo(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\tfeaturedOn:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(3)\n\t\t\t\t\t\t?.contents.map((item: any) =>\n\t\t\t\t\t\t\tPlaylistParser.parseArtistFeaturedOn(item, artistBasic),\n\t\t\t\t\t\t) ?? [],\n\t\t\t\tsimilarArtists:\n\t\t\t\t\ttraverseList(data, \"musicCarouselShelfRenderer\")\n\t\t\t\t\t\t?.at(4)\n\t\t\t\t\t\t?.contents.map((item: any) => this.parseSimilarArtists(item)) ?? [],\n\t\t\t},\n\t\t\tArtistFull,\n\t\t)\n\t}\n\n\tpublic static parseSearchResult(item: any): ArtistDetailed {\n\t\tconst columns = traverseList(item, \"flexColumns\", \"runs\").flat()\n\n\t\t// No specific way to identify the title\n\t\tconst title = columns[0]\n\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ARTIST\",\n\t\t\t\tartistId: traverseString(item, \"browseId\"),\n\t\t\t\tname: traverseString(title, \"text\"),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tArtistDetailed,\n\t\t)\n\t}\n\n\tpublic static parseSimilarArtists(item: any): ArtistDetailed {\n\t\treturn checkType(\n\t\t\t{\n\t\t\t\ttype: \"ARTIST\",\n\t\t\t\tartistId: traverseString(item, \"browseId\"),\n\t\t\t\tname: traverseString(item, \"runs\", \"text\"),\n\t\t\t\tthumbnails: traverseList(item, \"thumbnails\"),\n\t\t\t},\n\t\t\tArtistDetailed,\n\t\t)\n\t}\n}\n","import { SearchResult } from \"../types\"\nimport { traverseList } from \"../utils/traverse\"\nimport AlbumParser from \"./AlbumParser\"\nimport ArtistParser from \"./ArtistParser\"\nimport PlaylistParser from \"./PlaylistParser\"\nimport SongParser from \"./SongParser\"\nimport VideoParser from \"./VideoParser\"\n\nexport default class SearchParser {\n\tpublic static parse(item: any): SearchResult | null {\n\t\tconst flexColumns = traverseList(item, \"flexColumns\")\n\t\tconst type = traverseList(flexColumns[1], \"runs\", \"text\").at(0) as\n\t\t\t| \"Song\"\n\t\t\t| \"Video\"\n\t\t\t| \"Artist\"\n\t\t\t| \"EP\"\n\t\t\t| \"Single\"\n\t\t\t| \"Album\"\n\t\t\t| \"Playlist\"\n\n\t\tconst parsers = {\n\t\t\tSong: SongParser.parseSearchResult,\n\t\t\tVideo: VideoParser.parseSearchResult,\n\t\t\tArtist: ArtistParser.parseSearchResult,\n\t\t\tEP: AlbumParser.parseSearchResult,\n\t\t\tSingle: AlbumParser.parseSearchResult,\n\t\t\tAlbum: AlbumParser.parseSearchResult,\n\t\t\tPlaylist: PlaylistParser.parseSearchResult,\n\t\t}\n\n\t\tif (parsers[type]) {\n\t\t\treturn parsers[type](item)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n}\n","import YTMusic from \"./YTMusic\"\n\nexport type {\n\tAlbumBasic,\n\tAlbumDetailed,\n\tAlbumFull,\n\tArtistBasic,\n\tArtistDetailed,\n\tArtistFull,\n\tPlaylistDetailed,\n\tPlaylistFull,\n\tSearchResult,\n\tSongDetailed,\n\tSongFull,\n\tThumbnailFull,\n\tVideoDetailed,\n\tVideoFull,\n\tHomeSection,\n} from \"./types\"\n\nexport default YTMusic\n"]}